////////////////////////////////////////
// hist.comp
// computes the local Histogram for CLAHE
////////////////////////////////////////

#version 460 

//layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;	// 64 threads
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;	

// input Histogram
layout(std430, binding = 1) buffer inHist {
    uint hist[];
};

layout(std430, binding = 2) buffer inHistMax {
    uint histmax[];
};

// output the amount of excess pixels 
layout (std430, binding = 3) buffer excessPixels {
    uint excess[];
};

uniform uint NUM_BINS;      // number of gray values in the Final Volume
uniform float clipLimit;    // limit of pixel values
uniform uint minClipValue;  // lower limit for the Clip Value


 uniform ivec3 blocksDims;

void main() {

    uint index = gl_GlobalInvocationID.x;
    uint histIndex = index / NUM_BINS;

    // Compute the clip value of the current Histogram
    uint clipValue = uint( float( histmax[ histIndex ] ) * clipLimit );
    
    
    // Calculate the number of excess pixels
    atomicAdd( excess[ histIndex ], max(0, int(hist[index]) - int(clipValue)));
   


}
////////////////////////////////////////
//// hist.comp
//// computes the local Histogram for CLAHE
//////////////////////////////////////////
//
//#version 460 
//
////layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;	// 64 threads
//layout(local_size_x = 6, local_size_y = 6, local_size_z = 8) in;	// 288 threads
//
//// input Histogram
//layout(std430, binding = 1) buffer inHist {
//    uint hist[];
//};
//
//layout(std430, binding = 2) buffer inHistMax {
//    uint histmax[];
//};
//
//// output the amount of excess pixels 
//layout (std430, binding = 3) buffer excessPixels {
//    uint excess[];
//};
//
//uniform uint NUM_BINS;      // number of gray values in the Final Volume
//uniform float clipLimit;    // limit of pixel values
//uniform uint minClipValue;  // lower limit for the Clip Value
//
//
// uniform ivec3 blocksDims;
//
//void main() {
//
//    ivec3 index = ivec3(gl_LocalInvocationID.xyz);
//    uint localIndex = uint(index.z * index.y * index.x);
//    if(localIndex>NUM_BINS)
//        return;
//
//
//    ivec3 wgIndex = ivec3(gl_WorkGroupID.xyz);
//    uint histIndex = wgIndex.x*wgIndex.y*wgIndex.z;//32
//
//   	// figure out the sub Block histogram this index belongs to 
//    uint totalIndex = histIndex*NUM_BINS + localIndex;
//  
//
//    // Compute the clip value of the current Histogram
//    uint clipValue = uint( float( histmax[ histIndex ] ) * clipLimit );
//    clipValue = max(minClipValue, clipValue);
//    
//    // Calculate the number of excess pixels
//    atomicAdd( excess[ histIndex ], max(0, int(hist[totalIndex]) - int(clipValue)));
//   
//
//
//}
